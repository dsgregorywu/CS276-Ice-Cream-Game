# CS276-Ice-Cream-Game

Game Description: Ice Cream Delivery Dash is a game where you are an ice cream truck driver trying to collect and deliver ice cream cones to different houses around the neighborhood! The objective is to deliver all 4 ice creams as fast as possible. Each ice cream must be delivered to the house with the corresponding color, and only one ice cream can be carried at a time. You can't lose, but you can always shoot for a better score! Use your turbo feature to speed up, but be careful, as running into something or running out of turbo will make you spin out and lose control! What makes this game fun is the freedom of pathing, trying to find the most efficient routes, and shooting to complete it as fast as you can!

Technical implementation:

Levels: My game currently only has 1 level and isn't really described as a level. If I had more time I would make it into a multi level game, where each level gets more and more difficult. It's all based around using the scene manager to load the scene upon victory -> restart.
Sprites: I used lots of sprites, mostly the ones that were provided in the starting files. I looked around for better ice cream sprites but there weren't any good ones for free, so I settled for changing the color of the given sprite. Some examples of my sprites include the houses, trees, ice creams, and car object.
Prefabs: I used many prefabs, including some for basic houses, rocks, trees, bushes, grass patches, and fences. I didn't know about copy and pasting lines of prefabs until halfway through the project, which made lining the neighborhood with trees much easier. I tagged most of these with Static Nature which determined if the user would spin out upon collision.
Colliders: Collisions in my game are tag-based, which can dictate what happens on collision with the car, whether that is being picked up like the ice cream cones, delivering an ice cream like the houses, or making the user spin out like trees. Colliders are the basis for detecting collisions, which is a key piece of my game.
Rigidbodies: My game didn't require a whole lot of rigidbodies, but they do exist in the rocks that can be pushed around. I originally intended for this to be a shortcut that the user could find by running into it as they don't make the user spin out. 
Triggers: I used grass/offroad elements to slow the user down when they aren't on the road. I did this by detecting collisions when the user entered and exited an offroad area, changing the user's speed to be slower when they are in this area. Some examples include the grass patches and mud patch.
UI Text: The victory screen contains most of these, including the you win message and final time as well as the restart button, but the base game has a timer and a turbo meter that are both UI components. These were mostly implemented through a UI Canvas that allowed me to put things where I wanted them on the screen.
Sprite Movement: The player is the primary sprite that moves in this game, but the rocks can also move. Since the goal is to traverse the neighborhood in a predictable and repeatable way, I decided not to include many moving elements, since I want this to be a time trials/speedrunning game of sorts. The user movement was created using the cruise script that we worked on in class, with some modifications to add the turbo and spin out features.
Particle System: I use colored particles coming out of the back of the car to display which color ice cream cone the user is currently holding, as well as some on the house upon drop off to visually notify the user that they successfully dropped off an ice cream cone. I'm very proud of these ideas as they along with the audio effects make the game accessible for players with audio or visual difficulties.
GameObject Management: The main game object that changes is the ice cream cones, as they get picked up upon collision as long as the user doesn't currently have an ice cream cone. This is to make the game take longer, as the inverse would allow users to just do one lap around town and win super easily. 
Game Release: It exists! I pinky promise!
Extra:
Sound Managers - These keep track of the audio components I use for spinning out, dropping off an ice cream, background music, and victory music. They reference one another as well as the IceCreamDelivery/Cruise scripts in order to play at the right time.

Future Development Plan:
How would you extend the game with additional levels? - I would make the future levels more difficult, likely with more complex towns, more houses, more ice creams, and potentially some moving obstacles to catch players off guard. I think 3 levels would make for a great speedrunning/time trials feel, as it would break the game up very nicely and allow users to get lots of runs in in a short period of tine.
What new game objects or mechanics would you add? - As I said I would add some sort of moving obstacles, I would also make spin outs have variable length depending on the severity of the crash, where travelling faster upon crashing would spin the user out for longer.
How would you expand the story or theme? - I would like to do some sort of cutscene to introduce users to the basic story, but honestly I don't think this game requires as much story as many other games, as the goal isn't to complete the story, but just to get as fast at the game as possible. Maybe play around with the monster sprites that were in the starter files?

Development Reflection:

The most challenging aspect of this project was getting everything into my game. I have a lot of different aspects of my game that all interact with each other, as well as a lot of tiny specific details that matter a LOT. Trying to balance all of these from a coding perspective was difficult, as it felt like whenever I made one change to how two objects interact, it completely messed up a different interaction. I learned a lot about details and the game development process, as I wasn't very familiar with the process of adding particles or audio effects beforehand, but feel much more confident on those things now. Next time, I would plan out exactly what I wanted before I start development, as rushing straight into development made me have to go back and change a lot of things every time I pivoted what I wanted my game to be.
